- 추상클래스와 추상메서드

- 추상 메서드(Abstract Method)
	1. 메서드를 선언만하고 구현하지 않은것을 추상메서드라고 한다.(미완성된 메서드)
	2. 자식클래스들이 오버라이딩해서 사용한다.
	3. 오버라이딩에 강제성을 부여하기 위해 사용한다.
	
- 추상 메서드 문법
	abstract 반환타입 메서드명(매개변수);

- 추상 클래스(Abstract Class)
	클래스의 멤버로 추상메서드를 한개이상 가지는 클래스.

- 추상 클래스 선언
abstract class 클래스명{
	// 필드

	// 멤버 메서드

	// 추상 메서드
}

** 추상 클래스는 객체화 시킬수 없다! <= 미완성된 메서드를 가지고 있기 때문
** 자식 클래스가 상속받아서 자식클래스를 객체화해서 사용하면 된다.

- 추상클래스 사용하는 이유
부모 클래스의 기능 중 반드시 모든 자식클래스에서 오버라이딩 해야하는 기능이 있다면
추상 메서드 선언하는것이 좋다!

추상 메서드 선언하면 오버라이딩 강제성이 생기기 때문

- 인터페이스(interface)
	1. 일종의 추상클래스지만 크랠스라고 부르지 않으며 인터페이스라고 부른다.
	   추상화의 정도가 추상클래스보다 높다.
	
	2. 인터페이스의 멤버로는 추상메서드와 상수만 가질수 있다.

	3. 인터페이스는 객체화 할 수 없으며 자식클래스에서 구현(implements)해서 사용한다. 

- 인터페이스 선언
interface 인터페이스명{ // 인터페이스 작명 규칙도 클래스랑 똑같다.
	// 인터페이스 멤버
}

- 인터페이스의 멤버
1. 필드를 선언하면 무조건 public static final을 생략해도 붙혀준다.
2. 추상메서드를 선언하면 무조건 public abstract을 생략해도 붙혀준다.

** 주의사항 : 인터페이스의 추상메서드를 오버라이딩할 때 추상 메서드보다 접근제한자가 좁아지면 
	   안된다! 따라서 오버라이딩 할 때 항상 앞에 public을 붙혀줘야한다.

** 인터페이스도 타입니다!
   인터페이스가 부모이고 구현한 클래스가 자식클래스가 된다!

- 클래스의 상속과 인터페이스의 구현의 특징
1. 인터페이스는 인터페이스를 상속(extends)받을 수 있다.
2. 상속과 구현은 별개이므로 하나의 자식클래스가 상속과 구현을 동시에 받을 수 있다.
3. 클래스는 단일 상속만 가능하지만 인터페이스는 다중구현이 가능하다!

- 인터페이스를 사용하는 이유
1. 여러 클래스에서 선언할 멤버들을 일관되게 하기 위해서 사용한다!(표준화)

2. 서로 관계없는 클래스들을 하나의 타입으로 그룹화하는 용도로 사용한다.(마커 인터페이스)

- 어댑터 클래스(Adapter Class)
1. 인터페이스의 강제성을 완화시키는 목적으로 사용하는 추상클래스이다.
2. 어댑터 클래스는 추상클래스이기 때문에 구현된 멤버와 미구현된 멤버를 동시에 가질 수 있다.
   그래서 어댑터 클래스에서 인터페이스를 구현하고 강제성을 없애고싶은 추상메서드를 오버라이딩하면 된다.
   이후 어댑터 클래스를 상속받은 자식클래스는 원하는 메서드만 오버라이딩 할 수 있다.

3. 어댑터 클래스의 이름은 이름뒤에 Adapter를 붙혀서 목적을 알려주는것이 좋다.

- 인터페이스의 default 메서드
인터페이스 안에서 default 메서드를 사용하여 구현된 메서드를 만들 수 있다!

- 다중 상속
	하나의 자식 클래스가 여러 부모클래스를 상속받는것을 다중상속이라고 한다.
	JAVA는 모호성 문제 때문에 다중상속을 지원하지 않는다.(단일 상속만 가능)

	하지만 JDK8버전부터 인터페이스에 default메서드가 허용되므로
	다중상속을 지원하는것이나 다름없게 되었다.

- 모호성
하나의 자식클래스가 여러 부모를 상속받거나 구현할때 다른 부모들에게 동일한 이름의 멤버가 있다면 어떤 부모의 멤버를 가져올지 애매하다.

- 모호성 해결방법
1. 두개이상의 인터페이스에 같은 선언부의 추상메서드가 있는경우
   자식클래스에 재정의해서 사용한다.

2. 부모클래스의 메서드와 부모 인터페이스의 디폴트 메서드가 같은경우
   부모클래스의 메서드가 상속받는다. 

- 마커 인터페이스(Marker Interface)
1. 클래스들을 그룹화하기 위한 목적으로 사용한다.
2. 서로 다른 클래스들을 공통되는 타입을 갖도록 하는것이 유일한 목적이기 때문에
   마커인터페이스 안에는 보통 어떠한 멤버도 선언하지 않는다.

- 내부클래스(Inner Class)
	1. 클래스 내부에 선언된 클래스
	   내부클래스를 가지고 있는 클래스를 외부클래스(Outer Class)라고한다.
	2. 클래스를 구성하는 멤버로 변수,메서드,생성자 뿐만 아니라 클래스도 가질 수 있다.
	3. 만약 내부클래스의 멤버를 외부클래스 안에서만 사용한다면 내부클래스를 외부클래스 안에
	   만들어준다.
	4. 외부 클래스의 객체가 생성되야 내부클래스의 객체화가 가능하기 때문에
	   외부 클래스 없이 내부클래스를 별도로 사용하지는 못한다.
	5. 내부 클래스는 외부클래스의 멤버이므로 외부클래스의 다른 멤버들을 상속없이 사용할 수 있다.
	6. 메서드 안에서 클래스를 선언할 수 있다!!(로컬 내부클래스)
	 
- 내부 클래스의 종류
1. 인스턴스 내부 클래스(Instance Inner Class)
	클래스 영역 안에 선언된 내부 클래스

2. 스태틱 내부 클래스(Static Inner Class)
	static 키워드가 붙은 내부 클래스

3. 로컬 내부 클래스(Local Inner Class)
	메서드 영역안에 선언된 내부 클래스

- 익명 클래스(Anonymous Class)
	1. 이름이 없는 클래스이다.
	2. 미구현된 멤버를 구현하여 일회성으로 객체를 생성하기위해 사용한다.
	3. 인터페이스나 추상클래스를 자식클래스에서 재정의하지 않고 객체를 만들 때
	   바로 익명클래스로 재정의 해준다.

- 람다식(Lambda Expression)
	1. 기존에 익명클래스를 사용하는 방식은 작성하는 코드가 너무 길다!(간결X)
	   람다식은 이러한 코드를 간결하게 있는 식(expression)이다

	2. 람다식은 오직 하나의 추상메서드만 간결하게 오버라이딩 할 수 있다.
	3. 주로 함수형 인터페이스와 함께 사용한다.
	
- 함수형 인터페이스(Funtional Interface)
	단 하나의 추상메서드만을 가지는 인터페이스
	인터페이스 위에 @FunctionalInterface 이 어노테이션을 명시해주면
	해당 인터페이스를 함수형 인터페이스로 변환한다.

