## Casting <= 클래스 자료형간의 형변환
	1. Up Casting : 자식 객체를 부모타입으로 형변환 하는것
	부모클래스명 참조변수명 = new 자식클래스();

	** 업캐스팅을 하고 나면 자식캑체가 부모타입으로 변경되므로 자식 클래스에서 
	   추가적으로 정의한 멤버에 접근할 수 없다.
	
	2. Down Casting : 이미 업캐스팅 된 객체를 다시 자식 타입으로 변환하는것
	자식클래스명 참조변수명 = (자식클래스명)업캐스팅한 참조변수;
	
	업캐스팅이 가능한 이유는 자식객체가 부모클래스타입과 자식클래스타입을 동시에 가지기
	때문에 가능하다!

## Casting을 사용하는 이유
	부모타입인 하나의 저장공간(참조변수)에 여러 자식객체를 담을 수 있다.
	(참조변수의 다형성)

	만약 하나의 기능을 하는 메서드를 만들 때 매개변수로 여러 자식타입의 객체를 받아와야 
	하는 경우 Casting을 이용해서 매개변수로 부모타입의 객체를 받아올 수 있다.

	** 주의 사항
	1. Up Casting으로 자식객체를 받아온 경우 자식클래스에 오버라이딩한 기능이 실행된다.
	2. Up Casting으로 자식객체를 받아왔다면 자식클래스 새로 정의한 멤버를 사용할수 없다. 
	   이 때 Down Casting으로 복구하고 사용한다.

## 다형성 : 하나의것이 여러 형태를 가지는 성질
	오버로딩
	오버라이딩
	Casting

## instanceof 연산자
	앞에오는 참조변수(객체)가 뒤에오는 클래스타입인지 검사하여 결과를 true, false로 반환한다.

## 추상클래스와 추상메서드

## 추상 메서드
	1. 메서드를 선언만 하고 구현하지 않은 것을 추상메서드라고 한다. (미완성된 메서드)
	2. 자식 클래스들이 오버라이딩해서 사용한다.
	3. 오버라이딩에 강제성을 부여하기 위해 사용한다.

## 추상 메서드 문법
	abstract 반환타입 메서드명(매개변수);
	abstract void printHello();

## 추상 클래스
	멤버로 추상 메서드를 한개이상 가지고 있는 클래스는 추상 클래스로 선언해야한다.
	
## 추상 클래스 선언
abstract class 클래스명{
	// 필드
	
	// 멤버 메서드

	// 추상 메서드
}

** 추상 클래스는 객체화 시킬수 없다!!!!
** 자식 클래스가 상속받아서 자식클래스를 객체화하여 사용한다.

## 추상 클래스를 사용하는 이유
부모 클래스의 기능 중 반드시 모든 자식클래스에서 오버라이딩 해야하는 기능이 있다면
추상 메서드로 선언하는것이 좋다.

추상클래스를 상속받은 자식클래스는 부모클래스가 가지고 있는 추상메서드를
오버라이딩하지 않으면 오류가 발생하므로 오버라이딩에 [강제성]이 부여된다.

## 인터페이스(Interface)
	1. 일종의 추상 클래스이지만 클래스라고 부르지 않으며 인터페이스라고 부른다.
	   추상화의 정도가 높다.
	
	2. 인터페이스는 멤버로 상수와 추상 메서드만 가질 수 있다.

	3. 인터페이스는 객체화 할수 없으며 자식클래스에서 구현해서 사용한다.
	구현할 때는 implements 키워드를 사용한다.

## 인터페이스 선언
interface 인터페이스명{ // 클래스 작명규칙과 똑같다.
	// 인터페이스의 멤버
}

## 인터페이스의 멤버
1. 인터페이스는 메버로 상수와 추상메서드만 가질 수 있다!
2. 필드를 선언하면 무조건 public static final을 생략해도 붙혀준다.
3. 추상 메서드를 선언하면 무조건 public abstract를 생략해도 붙혀준다.
	
** 주의사항 : 인터페이스를 추상메서드를 오버라이딩 할 때 추상 메서드보다 접근범위가 좁아지면
	   안되므로 항상 오버라이딩 할 때 메서드 앞에 public을 붙혀줘야한다.

** 인터페이스도 타입이다.
   인터페이스가 부모이고 구현할 클래스가 자식이다.

## 클래스의 상속과 인터페이스의 구현의 특징
1. 인터페이스는 인터페이스를 상속(extends)받을 수 있다.
2. 상속과 구현은 별개이므로 하나의 클래스가 상속과 구현을 동시에 할 수 있다.
3. 클래스는 단일 상속만 가능하지만 인터페이스는 다중 구현이 가능하다!

## 인터페이스를 사용하는 이유
1. 여러 클래스에서 선언할 멤버들을 일관되게 하기 위해 사용한다. (표준화)

2. 관계없는 클래스들을 그룹화하는 용도로 사용한다.(마커 인터페이스)

## 인터페이스의 불편함
인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부 추상메서드만 재정의 하여 상용하는것이
불가능하다.
이를 해결하기 위해 Adapter라는 추상클래스를 활용한다.

## 어댑터 클래스(AdapterClass)
1. 인터페이스의 강제성을 완화시키기 위해 Adapter 클래스를 사용한다.

2. 어댑터 클래스는 추상클래스로 만들기 때문에 미구현된 메서드와 멤버 메서드가 동시에 존재할 수 있다.
그러므로 어댑터 클래스에서 인터페이스를 구현하고 강제성을 없애고 싶은 메서드만 재정의 해줄 수 있다.

3. 이후 어댑터 클래스를 상속받는 클래스는 원하는 메서드만 오버라이딩 할 수 있다.

4. 어댑터 클래스의 이름은 이름뒤에 Adapter를 붙혀서 목적을 알려주는것이 좋다.


## 인터페이스 default 메서드
인터페이스 안에서 default 메서드를 사용하여 추상메서드를 구현할 수 있다.
