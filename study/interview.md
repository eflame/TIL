
<h2>백엔드 기본</h2>
<dl>
  <dt>프로세스와  스레드를  설명하세요</dt>
  <dd>프로세스: 프로세스는 운영체제에서 실행 중인 프로그램의 인스턴스입니다. 프로세스는 독립적인 메모리 공간을 가지며, 다른 프로세스와 메모리나 자원을 공유하지 않습니다. 각 프로세스는 자신의 주소 공간을 가지고 있어, 다른 프로세스의 메모리에 직접 접근할 수 없습니다.
</dd>
  <dd>스레드: 스레드는 프로세스 내에서 실행되는 작은 단위로, 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다. 스레드는 같은 프로세스 내의 자원(메모리, 파일 등)을 공유합니다. 다중 스레드 프로그래밍을 통해, 병렬 처리를 구현할 수 있습니다.</dd>

  <dt>컴파일러와  인터프리터를  설명하세요 </dt>
  <dd>컴파일러는 소스 코드를 한번에 기계어로 변환하여 실행 파일을 생성합니다. 이후 실행 파일을 실행하면 프로그램이 실행됩니다. C, C++, Java 등의 언어는 컴파일러를 사용합니다.</dd>
  <dd>인터프리터는 소스 코드를 한 줄씩 읽고, 그때그때 기계어로 번역하여 실행합니다. 중간에 에러가 발생하면 즉시 멈추고, 에러가 발생한 시점까지의 코드만 실행됩니다. Python, Ruby, JavaScript 등이 인터프리터 언어입니다.</dd>

  <dt>동기와  비동기를  설명해주세요</dt>
  <dd>동기 방식은 작업이 순차적으로 처리되며, 하나의 작업이 끝나야 다음 작업이 실행됩니다. 결과가 반환될 때까지 기다려야 합니다.</dd>
  <dd>비동기 방식은 작업이 병렬적으로 처리될 수 있으며, 이전 작업이 완료되지 않아도 다음 작업을 실행할 수 있습니다. 결과를 기다리지 않고, 완료되면 통보를 받거나 콜백 함수가 실행됩니다.</dd>

  <dt>디자인  패턴이  무엇인지  설명하세요</dt>
  <dd>디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제를 해결하기 위한 일반적인 재사용 가능한 솔루션입니다. 이는 특정 문제를 해결하는 모범적인 방식으로, 객체지향 프로그래밍에서 특히 많이 사용됩니다.</dd>

  <dt>알고있는  디자인  패턴하나를  설명해보세요</dt>
  <dd>싱글톤 패턴은 클래스의 인스턴스를 하나만 생성하여 전역적으로 접근할 수 있게 하는 디자인 패턴입니다. 주로 전역적으로 공유되는 자원이 필요할 때 사용됩니다. 예를 들어, 데이터베이스 연결 객체를 싱글톤으로 구현하여 여러 곳에서 동일한 인스턴스를 공유할 수 있습니다.</dd>

  <dt>MSA(마이크로 서비스 아키텍처)와 모놀리틱 아키텍처를 설명하세요 </dt>
  <dd>MSA는 애플리케이션을 작은 독립적인 서비스로 나누어 개발하는 아키텍처입니다. 각 서비스는 독립적으로 배포되고, 서로 다른 언어나 기술을 사용할 수 있습니다. 이는 확장성과 유지보수성을 높여줍니다.</dd>
  <dd>모놀리틱 아키텍처는 애플리케이션의 모든 기능이 하나의 코드베이스에 포함된 구조입니다. 모든 모듈이 tightly coupled 되어 있으며, 확장성 및 유지보수가 어렵다는 단점이 있습니다.</dd>

  <dt>절차지향 프로그래밍과 객체지향 프로그래밍의 차이를 설명하세요 </dt>
  <dd>절차지향 프로그래밍은 프로그램을 함수나 절차 단위로 나누어 처리하는 방식입니다. 주로 데이터를 처리하는 절차(함수)에 중점을 둡니다. 대표적인 언어로는 C가 있습니다.</dd>
  <dd>객체지향 프로그래밍은 데이터를 객체라는 단위로 묶어 처리하는 방식입니다. 객체는 데이터(속성)와 이 데이터를 처리하는 메서드(행동)를 함께 포함합니다. OOP는 캡슐화, 상속, 다형성 등의 개념을 포함하여 코드를 재사용하고 유지보수하기 쉽게 만듭니다. 대표적인 언어로는 Java, C++ 등이 있습니다.</dd>

  <dt>프레임워크와 라이브러리를 설명하세요</dt>
  <dd>프레임워크는 애플리케이션 개발의 구조를 제공하는 소프트웨어 플랫폼입니다. 개발자는 프레임워크가 제공하는 구조 내에서 필요한 기능을 구현합니다. 프레임워크는 전체적인 흐름을 제어하며, 개발자가 호출하는 형태로 동작합니다. 대표적인 프레임워크로는 Spring (Java), Django (Python) 등이 있습니다.</dd>
  <dd>라이브러리는 특정 기능을 수행하는 코드의 집합으로, 개발자가 필요할 때 호출하여 사용하는 모듈입니다. 라이브러리는 개발자가 코드를 작성하는데 도움을 주며, 프로그램의 흐름을 제어하지 않습니다. 예를 들어, Python의 Pandas 라이브러리는 데이터 분석 작업을 도와줍니다.</dd>

  <dt>주소창에 www.naver.com을  치면  어떤  일이  일어나는지  과정을  설명하세요 </dt>
  <dd>DNS 조회 - IP 주소 획득 - TCP 연결 - HTTP 요청 - 서버 처리 - HTTP 응답 - 렌더링 - 페이지 표시</dd>
  <dd>브라우저는 도메인 이름(www.naver.com)을 IP 주소로 변환하기 위해 DNS 서버에 요청을 보냅니다.</dd>
  <dd>DNS 서버는 해당 도메인의 IP 주소를 브라우저에 반환합니다.</dd>
  <dd>브라우저는 웹 서버의 IP 주소로 TCP 연결을 생성합니다. 3-way handshake 과정이 이루어집니다.</dd>
  <dd>브라우저는 HTTP GET 요청을 생성하여 웹 서버에 전송합니다.</dd>
  <dd>웹 서버는 요청을 처리하고, 요청된 리소스(HTML, CSS, JavaScript 파일 등)를 준비합니다.</dd>
  <dd>웹 서버는 준비된 리소스를 HTTP 응답으로 브라우저에 반환합니다.</dd>
  <dd>브라우저는 수신된 HTML을 파싱하고, CSS와 JavaScript 파일을 로드하여 페이지를 렌더링합니다.</dd>
  <dd>브라우저는 완성된 웹 페이지를 사용자에게 표시합니다.</dd>

  <dt>GET과 POST 차이를  설명하세요</dt>
  <dd>GET 메서드는 서버에서 데이터를 요청할 때 사용됩니다. 요청 데이터는 URL의 쿼리 파라미터로 전달되며, URL에 노출됩니다. GET 요청은 캐시될 수 있고, 보통 조회 요청에 사용됩니다.</dd>
  <dd>POST 메서드는 서버에 데이터를 전송할 때 사용됩니다. 요청 데이터는 HTTP 본문에 포함되어 전송되며, URL에 노출되지 않습니다. 보통 데이터를 생성하거나 서버에 변경사항을 전달하는 요청에 사용됩니다.</dd>


  <dt>세션과  쿠키를  설명하세요 </dt>
  <dd>세션은 서버에서 생성되어 사용자별로 상태를 유지하는 방식입니다. 세션 데이터는 서버에 저장되며, 세션 ID는 쿠키를 통해 클라이언트에 전달됩니다. 사용자가 서버에 접속할 때마다 동일한 세션 ID를 통해 서버는 사용자를 식별할 수 있습니다.</dd>
  <dd>쿠키는 클라이언트(브라우저)에 저장되는 작은 데이터 파일입니다. 서버는 클라이언트에 쿠키를 설정할 수 있으며, 이후의 HTTP 요청에서 해당 쿠키를 전송하여 사용자 상태를 유지할 수 있습니다. 쿠키는 주로 사용자 인증, 세션 관리 등에 사용됩니다.</dd>

  <dt>RESTful에  대해  설명하세요 </dt>
  <dd>RESTful은 REST (Representational State Transfer) 원칙을 따르는 웹 서비스 설계를 말합니다. RESTful 서비스는 자원을 URI로 식별하고, HTTP 메서드를 통해 자원에 대한 CRUD 작업을 수행합니다. RESTful API는 클라이언트와 서버 간의 통신을 단순화하고, 일관된 구조를 제공합니다.</dd>

  <dt>HTTP method를  설명하세요</dt>
  <dd>GET: 자원을 조회할 때 사용됩니다.
POST: 자원을 생성하거나 데이터를 전송할 때 사용됩니다.
PUT: 자원을 수정할 때 사용됩니다. 자원이 존재하지 않으면 새로 생성합니다.
DELETE: 자원을 삭제할 때 사용됩니다.
PATCH: 자원의 일부를 수정할 때 사용됩니다.</dd>

  <dt>HTTP status code 를  설명하세요</dt>
  <dd>200 OK: 요청이 성공적으로 처리되었습니다.

  301 Moved Permanently: 요청한 자원이 영구적으로 다른 위치로 이동되었습니다.
  
  400 Bad Request: 잘못된 요청입니다.
  
  401 Unauthorized: 인증이 필요합니다.
  
  403 Forbidden: 서버가 요청을 거부했습니다.
  
  404 Not Found: 요청한 자원을 찾을 수 없습니다.
  
  500 Internal Server Error: 서버에 오류가 발생했습니다.
</dd>
</dl>

<h2>JAVA 관련 질문들</h1>
<dl>
  <dt>JVM에  대해  설명하세요</dt>
  <dd>JVM은 Java 프로그램을 실행하기 위한 가상 머신입니다. 자바 바이트코드를 운영체제와 상관없이 실행할 수 있게 해줍니다. JVM은 메모리 관리(GC), 실행 엔진, 라이브러리 등을 포함합니다.
16. JAVA의 컴파일 과정 설명</dd>

  <dt>JAVA의 컴파일 과정에 대해 설명하세요 </dt>
  <dd>Java 소스 코드는 .java 파일로 작성되고, 이 파일은 javac 컴파일러를 통해 바이트코드(.class 파일)로 변환됩니다. 이 바이트코드는 JVM에 의해 실행됩니다.</dd>
  
  <dt>JDK17을 사용했는데 특징을 말해보세요</dt>
  <dd>LTS(장기 지원) 버전으로, 다양한 새로운 기능과 성능 개선이 포함되어 있습니다. 예를 들어, sealed classes, pattern matching for switch, foreign function & memory API 등이 포함됩니다.</dd>
  
  <dt>GC에 대해 설명하세요</dt>
  <dd>JVM의 메모리 관리 기능으로, 더 이상 참조되지 않는 객체를 자동으로 메모리에서 제거하여 메모리 누수를 방지합니다. GC는 여러 가지 알고리즘(Mark-Sweep, G1 GC 등)을 사용하여 효율적으로 동작합니다.</dd>
  
  <dt>OOP(객체지향프로그래밍)에  대해  설명하세요</dt>
  <dd>객체지향 프로그래밍은 데이터와 데이터를 조작하는 메서드를 객체로 묶어 표현합니다. OOP의 주요 개념에는 상속, 다형성, 캡슐화, 추상화가 포함됩니다.</dd>
  
  <dt>다형성에  대해  설명하세요</dt>
  <dd>다형성은 같은 인터페이스나 부모 클래스에 대해 여러 가지 형태의 객체가 사용할 수 있는 능력입니다. 다형성은 메서드 오버로딩과 오버라이딩을 통해 구현됩니다.</dd>

  
  <dt>클래스와  객체의  차이를  설명하세요 </dt>
  <dd>클래스: 객체의 설계도 혹은 청사진으로, 객체가 가져야 할 속성과 메서드를 정의합니다.</dd>
  <dd>객체: 클래스를 기반으로 생성된 인스턴스로, 실제로 동작하는 실체입니다.</dd>
  
  <dt>추상클래스와  인터페이스를  설명하세요</dt>
  <dd>추상 클래스는 인스턴스화될 수 없고, 서브클래스가 상속받아 구현해야 하는 메서드를 가질 수 있는 클래스입니다.</dd>
  <dd>인터페이스는 구현체 없이 메서드 시그니처만 정의하는 추상적인 개념으로, 클래스가 이를 구현해야 합니다.</dd>
  
  <dt>상속과  구현을  설명하세요</dt>
  <dd>자식 클래스가 부모 클래스의 속성과 메서드를 상속받아 사용할 수 있게 합니다.</dd>
  <dd>인터페이스에서 정의된 메서드를 실제로 구현하는 과정을 말합니다.</dd>
  
  <dt>오버로딩과  오버라이딩에  대해  설명하세요 </dt>
  <dd>오버로딩 (Overloading): 같은 이름의 메서드를 인자의 타입이나 개수에 따라 여러 개 정의할 수 있는 기능입니다.</dd>
  <dd>오버라이딩 (Overriding): 자식 클래스가 부모 클래스의 메서드를 재정의하여 사용하는 것입니다.</dd>
  
  <dt>Primitive Type과 Reference Type에  대해  설명하세요</dt>
  <dd>Primitive Type: Java의 기본 데이터 타입으로, int, char, boolean 등이 있습니다. 값이 직접 메모리에 저장됩니다.</dd>
  <dd>Reference Type: 객체의 주소를 참조하는 타입으로, 클래스, 배열, 인터페이스 등이 포함됩니다.</dd>
  
  <dt>Wrapper 타입이  무엇인지  설명하세요</dt>
  <dd>Primitive 타입을 객체로 다룰 수 있도록 감싸주는 클래스입니다. 예를 들어, int는 Integer, char는 Character로 감싸집니다.</dd>
  
  <dt>박싱과  언박싱을  설명하세요</dt>
  <dd>Primitive 타입을 Wrapper 클래스로 변환하는 과정입니다.</dd>
  <dd>Wrapper 클래스를 Primitive 타입으로 변환하는 과정입니다.</dd>
  
  <dt>접근  제어자에  대해  설명하고  종류와  특징을  설명하세요 </dt>
  <dd>
  접근 제어자: 클래스, 메서드, 변수 등의 접근 권한을 지정하는 키워드입니다. 주요 접근 제어자로는 private, default, protected, public이 있습니다.
  private: 해당 클래스 내에서만 접근 가능
  default: 같은 패키지 내에서만 접근 가능
  protected: 같은 패키지와 자식 클래스에서 접근 가능
  public: 모든 클래스에서 접근 가능
  </dd>
  
  <dt>ArrayList와  배열의  차이를  설명하세요</dt>
  <dd>배열: 고정된 크기를 가지며, 동일한 타입의 요소를 저장하는 자료구조입니다.</dd>
  <dd>ArrayList: 크기가 동적으로 변할 수 있으며, 배열을 기반으로 하지만 더 많은 기능을 제공하는 Java 컬렉션 클래스입니다.</dd>

  <dt>컬렉션  프레임워크  종류를  설명하세요(List, Set, Map에  대한  설명) </dt>
  <dd>
    List: 순서가 있는 요소의 집합으로, 중복을 허용합니다. 예: ArrayList, LinkedList.
    Set: 순서가 없고, 중복을 허용하지 않는 요소의 집합입니다. 예: HashSet, TreeSet.
    Map: 키-값 쌍으로 이루어진 데이터 집합으로, 키는 중복을 허용하지 않으며 값은 중복을 허용할 수 있습니다. 예: HashMap, TreeMap.
  </dd>
  
  <dt>Iterator를  설명하세요</dt>
  <dd>컬렉션 프레임워크에서 요소들을 순회(traverse)하는 인터페이스입니다. hasNext(), next(), remove() 메서드를 제공하여 컬렉션의 요소를 하나씩 접근할 수 있습니다.</dd>
  
  <dt>this와 super를 설명하세요</dt>
  <dd>
    this: 현재 인스턴스를 참조하는 키워드로, 인스턴스 변수와 지역 변수를 구분하거나, 생성자에서 다른 생성자를 호출할 때 사용됩니다.
    super: 부모 클래스를 참조하는 키워드로, 부모 클래스의 변수나 메서드를 호출하거나, 부모 클래스의 생성자를 호출할 때 사용됩니다.
  </dd>
  
  <dt>static 키워드를 설명하세요</dt>
  <dd>static: 클래스 변수나 메서드를 정의할 때 사용되는 키워드로, 인스턴스에 종속되지 않고 클래스 자체에 속합니다. 모든 인스턴스가 동일한 static 변수나 메서드를 공유합니다.</dd>
  
  <dt>if문이  아닌 try catch로  예외를  처리하는  이유를  설명하세요</dt>
  <dd>if문은 예외 상황을 미리 예측하고 회피하는 방식이고, try-catch는 실제 예외가 발생했을 때 이를 처리하는 방식입니다. 예외 상황이 복잡하거나 예측하기 어려운 경우, try-catch로 명확하게 예외를 처리하는 것이 좋습니다.</dd>
  
  <dt>자바에서  예외처리를  어떻게  하는지  설명하세요</dt>
  <dd>try, catch, finally, throw, throws 키워드를 사용하여 예외를 처리합니다. try 블록 내에서 발생한 예외는 catch 블록에서 처리되며, finally 블록은 예외 발생 여부와 관계없이 실행됩니다.</dd>
  
  <dt>제네릭이  무엇인지  설명하세요</dt>
  <dd>제네릭은 클래스나 메서드에서 사용할 데이터 타입을 미리 지정하지 않고, 사용할 때 지정할 수 있도록 하는 기능입니다. 이는 타입 안전성을 높이고, 코드 재사용성을 증가시킵니다. 예를 들어, List<String>은 문자열만을 포함하는 리스트를 의미합니다.</dd>
  
  <dt>람다식이  무엇인지  설명하고  사용  방식을  설명하세요</dt>
  <dd>람다식은 익명 함수를 간결하게 표현하는 방법입니다. Java 8부터 지원되며, 코드의 가독성을 높이고 불필요한 익명 클래스 생성을 줄입니다. 예를 들어, (a, b) -> a + b는 두 숫자를 더하는 람다식입니다.</dd>
  
  <dt>쓰레드와  멀티쓰레드에  대해  설명하세요</dt>
  <dd>쓰레드는 프로세스 내에서 실행되는 작은 단위입니다.</dd>
  <dd>멀티쓰레드는 하나의 프로세스 내에서 여러 쓰레드를 동시에 실행하여 병렬 처리를 구현하는 방식입니다. 이를 통해 프로그램의 성능을 향상시킬 수 있습니다.</dd>

  <dt>Call By Value와 Call By Reference를  설명하세요</dt>
  <dd>Call By Value: 함수를 호출할 때, 실제 값이 아닌 값의 복사본이 전달됩니다. 원본 데이터는 변경되지 않습니다.</dd>
  <dd>Call By Reference: 함수를 호출할 때, 데이터의 참조(주소)가 전달되며, 이로 인해 원본 데이터가 변경될 수 있습니다.</dd>
</dl>

<h2>DB 관련 질문들</h2>
<dl>
  <dt>RDBMS를  설명하세요 </dt>
  <dd>RDBMS는 데이터베이스의 데이터를 테이블로 구조화하여 저장하고 관리하는 시스템입니다. 관계형 모델을 기반으로 하며, SQL을 사용하여 데이터를 쿼리합니다.</dd>
  
</dl>

41. 정규화 설명

정규화 (Normalization):
데이터베이스 설계에서 중복을 최소화하고, 데이터의 무결성을 유지하기 위해 데이터를 구조화하는 과정입니다. 주로 1NF, 2NF, 3NF의 단계로 나뉩니다.
42. 반정규화 설명

반정규화 (Denormalization):
성능 향상을 위해 정규화된 데이터베이스를 의도적으로 중복을 허용하거나, 결합하는 과정입니다. 이는 쿼리 성능을 높이기 위해 사용됩니다.
43. 무결성 설명

무결성 (Integrity):
데이터의 정확성과 일관성을 유지하기 위한 제약 조건입니다. 주요 무결성에는 개체 무결성, 참조 무결성, 도메인 무결성이 포함됩니다.
44. 트랜잭션 설명

트랜잭션 (Transaction):
데이터베이스에서 하나의 논리적 작업 단위를 이루는 연산들의 집합으로, ACID(Atomicity, Consistency, Isolation, Durability) 특성을 갖습니다. 트랜잭션은 모두 성공하거나 모두 실패해야 합니다.
45. DELETE와 TRUNCATE의 차이 설명

DELETE:
테이블의 특정 행을 삭제하며, WHERE 절을 사용할 수 있습니다. 롤백이 가능합니다.
TRUNCATE:
테이블의 모든 데이터를 삭제하며, 롤백이 불가능합니다. 테이블 구조는 유지됩니다.
46. PK와 FK 설명

PK (Primary Key):
테이블의 각 행을 고유하게 식별하는 컬럼입니다. 중복될 수 없으며, NULL 값을 가질 수 없습니다.
FK (Foreign Key):
다른 테이블의 기본 키를 참조하여 테이블 간의 관계를 설정하는 컬럼입니다. 무결성을 유지하는 데 사용됩니다.
47. 조인 종류와 특징 설명

INNER JOIN:
두 테이블 간의 일치하는 행만 반환합니다.
LEFT JOIN (LEFT OUTER JOIN):
왼쪽 테이블의 모든 행과 일치하는 오른쪽 테이블의 행을 반환합니다. 오른쪽 테이블에 일치하는 값이 없으면 NULL을 반환합니다.
RIGHT JOIN (RIGHT OUTER JOIN):
오른쪽 테이블의 모든 행과 일치하는 왼쪽 테이블의 행을 반환합니다. 왼쪽 테이블에 일치하는 값이 없으면 NULL을 반환합니다.
FULL JOIN (FULL OUTER JOIN):
두 테이블의 모든 행을 반환하며, 일치하지 않는 행에는 NULL을 반환합니다.
48. JOIN에서 ON과 WHERE 사용 차이 설명

ON:
조인 조건을 지정할 때 사용하며, JOIN 구문 내에서 조건을 설정합니다.
WHERE:
조인이 완료된 후 결과에 대해 추가 조건을 설정할 때 사용합니다. 필터링 역할을 합니다.
49. Group By 설명

Group By:
동일한 값을 가진 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수(SUM, COUNT 등)를 적용할 때 사용합니다.
50. Group By에서 Having과 WHERE 차이 설명

WHERE:
그룹화되기 전에 행을 필터링하는데 사용됩니다.
HAVING:
그룹화된 이후에 그룹에 대해 조건을 걸 때 사용됩니다. 주로 집계 함수와 함께 사용됩니다.
51. 동적 쿼리 설명

동적 쿼리 (Dynamic Query):
실행 시점에 조건에 따라 SQL 구문이 동적으로 생성되는 쿼리입니다. 다양한 조건을 처리할 수 있으며, 유연성이 높지만, 성능과 보안 문제에 주의해야 합니다.
52. JDBC 설명

JDBC (Java Database Connectivity):
자바에서 데이터베이스와 연결하고 SQL 쿼리를 실행할 수 있는 API입니다. JDBC를 통해 자바 애플리케이션은 다양한 RDBMS에 접속하고 데이터를 처리할 수 있습니다.
웹 개발 관련 질문들
53. 서블릿 설명

서블릿 (Servlet):
자바를 기반으로 웹 요청을 처리하고, 동적 웹 콘텐츠를 생성하는 서버 측 프로그램입니다. HTTP 요청과 응답을 처리하며, 자바 웹 애플리케이션의 핵심 구성 요소입니다.
54. WS(웹 서버)와 WAS(웹 애플리케이션 서버) 차이 설명

웹 서버 (WS):
정적 콘텐츠(HTML, 이미지 등)를 클라이언트에 제공하는 서버입니다. 주로 HTTP 요청을 처리합니다.
웹 애플리케이션 서버 (WAS):
동적 콘텐츠를 생성하고 실행하는 서버로, 웹 서버 기능에 더해 비즈니스 로직을 처리하는 애플리케이션을 실행할 수 있습니다.
55. 웹 브라우저의 HTML 렌더링 과정 설명

HTML 렌더링 과정:
브라우저가 HTML 파일을 받아 파싱(parsing)하여 DOM(Document Object Model) 트리를 생성합니다.
CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다.
DOM과 CSSOM을 결합하여 렌더 트리를 만듭니다.
레이아웃 단계에서 요소의 크기와 위치를 계산합니다.
페인트 단계에서 각 요소를 화면에 그립니다.
56. 스프링 설명

스프링 (Spring):
자바 기반의 프레임워크로, 엔터프라이즈 애플리케이션 개발을 단순화하고, 효율적으로 만들기 위해 다양한 기능을 제공합니다. DI(Dependency Injection), AOP(Aspect-Oriented Programming) 등을 지원하며, 모듈화된 아키텍처를 제공합니다.
57. 스프링과 스프링 부트 차이 설명

스프링:
자바 엔터프라이즈 애플리케이션 프레임워크로, 다양한 기능을 제공하지만 설정이 복잡할 수 있습니다.
스프링 부트:
스프링의 설정을 간소화하고, 빠른 개발을 위해 자동 설정을 제공하는 프레임워크입니다. 독립 실행형 애플리케이션을 쉽게 만들 수 있도록 도와줍니다.
58. 스프링 MVC 설명

스프링 MVC:
스프링 프레임워크의 웹 모듈로, 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 웹 애플리케이션을 구성합니다. 클라이언트의 요청을 컨트롤러가 처리하고, 결과를 모델에 담아 뷰로 전달합니다.
59. DI 설명

DI (Dependency Injection):
의존성 주입은 객체 간의 의존성을 외부에서 주입하는 방식입니다. 스프링에서는 DI를 통해 객체 간의 결합도를 낮추고, 유연하고 테스트하기 쉬운 코드를 작성할 수 있습니다.
60. 필터, 인터셉터, AOP 설명

필터 (Filter):
웹 요청에 대해 전처리 및 후처리를 수행하는 객체로, 주로 서블릿 컨테이너에서 작동합니다. 인증, 인코딩 설정 등을 처리합니다.
인터셉터 (Interceptor):
스프링 MVC에서 요청 전후에 추가 작업을 수행할 수 있도록 하는 객체입니다. 컨트롤러 진입 전에 수행됩니다.
AOP (Aspect-Oriented Programming):
관점 지향 프로그래밍은 공통 기능을 분리하여 모듈화하는 프로그래밍 패러다임으로, 주로 로깅, 보안, 트랜잭션 관리에 사용됩니다.
61. 테스트 코드 검증 라이브러리 사용 여부

테스트 코드 검증 라이브러리:
JUnit, AssertJ, Hamcrest 등이 있습니다. 테스트 코드에서 예상 결과를 검증하기 위해 사용됩니다. AssertJ는 유창한 API를 제공하며, 코드의 가독성을 높여줍니다.
62. Mockito 사용 경험과 이유 설명

Mockito:
단위 테스트에서 의존성 있는 객체를 모킹(mocking)하여 독립적으로 테스트할 수 있게 해주는 프레임워크입니다. 실제 객체 대신 모킹 객체를 사용하여 테스트의 복잡성을 줄이고, 특정 메서드의 동작을 시뮬레이션할 수 있습니다.
63. 템플릿 엔진 설명

템플릿 엔진:
동적인 HTML 페이지를 생성하기 위해 서버 측에서 사용하는 도구입니다. HTML 코드와 데이터를 결합하여 최종 HTML을 생성합니다. 예로는 Thymeleaf, FreeMarker, JSP 등이 있습니다.
64. CORS 문제 설명

CORS (Cross-Origin Resource Sharing):
다른 도메인에서 리소스를 요청할 때 발생할 수 있는 보안 문제를 해결하기 위한 메커니즘입니다. 브라우저는 다른 출처에서의 요청을 제한하며, 서버에서 적절한 CORS 헤더를 설정하여 이를 허용할 수 있습니다.
65. RESTful API 설명

RESTful API:
REST(Representational State Transfer) 원칙을 따르는 API로, HTTP 메서드를 사용하여 자원을 관리합니다. RESTful API는 클라이언트와 서버 간의 통신을 단순화하고, 자원의 상태를 표준화된 방식으로 전달합니다.
66. 마이크로서비스 설명

마이크로서비스:
애플리케이션을 작은 단위의 독립적인 서비스들로 구성하는 아키텍처입니다. 각 서비스는 고유한 비즈니스 기능을 수행하며, 서로 독립적으로 배포 및 확장될 수 있습니다. 마이크로서비스는 느슨하게 결합되어 있으며, API를 통해 통신합니다.
