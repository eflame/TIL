# 클래스
1. 사용자 정의 타입이다. (자료형)
	- 클래스를 사용하면 여러 타입, 여러 값을 저장할 수 있는 저장 공간을 만들 수 있다.

2. 객체를 생성하기 위한 틀, 설계도이다.

3. 연관성이 있는 저장공간과 기능을 한 곳에 모아 편하게 관리할 수 있는것

# 객체(Object)와 인스턴스(instance)
- 객체 : 실제 사물 또는 개념
- 클래스 : 객체를 컴퓨터에 옮기기 위해 추상화한 것
* 추상화 : 어떤 것의 특징(속성, 행위)을 추려내는 과정
- 인스턴스 : 클래스를 이용하여 메모리에 저장공간을 만든 것
	물리적으로 존재하는 공간

# 클래스 선언
class 클래스명{
	변수; // 멤버 변수, 필드

	메서드(){} // 멤버 메서드

         // class를 구성하는 모든 필드, 메서드 등을 합쳐서 멤버라고 부른다.
*추상화 : 어떤 것의 특징(속성, 행위)을 추려내는 과정
- 인스턴스 : 클래스를 이용하여 메모리에 저장공간을 만든 것
	     물리적으로 존재하는 공간

# 클래스 선언
class 클래스명 {
	변수; // 멤버 변수, 필드
	
	메서드(){} //멤버 메서드 

	// class를 구성하는 모든 필드, 메서드 등을 합쳐서 멤버라고 부른다.
}

# 인스턴스화(객체화) : instantiation
	객체를 만드는 작업
	추상적인 개념을 구체화시키는 작업

	클래스명 변수명 = new 클래스명();

# 객체 사용 방법
	변수명.멤버명
	.(점) : 하위 연산자, 멤버접근 연산자 ,....

# 인터페이스(interface)
일종의 추상 클래스이지만 클래스라고 부르지 않으며 추상화의 정도가 높다.
멤버로는 정적 상수와 추상 메서드만 가질 수 있다.
인터페이스는 객체화 할 수 없으며, 인터페이스는 다른 클래스에서 구현(implements)해서 사용한다.(상속과 비슷)

# 인터페이스의 멤버
1. 모든 필드는 public static final이다.
2. 모든 메서드는 public abstract이다.

# 클래스의 상속과 인터페이스의 구현
1. 클래스는 단일 상속만 가능하며, 인터페이스는 다중 구현이 가능하다.
2. 상속과 구현은 별개이다.
   즉, 하나의 클래스에 상속과 구현을 동시에 할 수 있다.
3. 인터페이스는 인터페이스르르 상속(extends)할 수 있다.


# 인터페이스를 사용하는 이유
1. 여러 클래스에서 선언할 맴버들을 일관되게 하기 위해 사용(표준화)
2. 관계없는 클래스들을 그룹화 시키기 위해 사용(마커 인터페이스)

# 인터페이스의 불편함
인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는게 불가능하다.
이를 해결하기 위해 Adapter라는 추상 클래스를 활용할 수 있다.

# 어댑터 클래스와 인터페이스
인터페이스의 강제성을 완화시키기 위해서 Adapter클래스를 사용할 수 있다.
어댑터 클래스를 추상 클래스로 선언하면 미구현된 메서드와 구현된 메서드를 동시에 가질 수 있다.
그러므로 어댑터 클래스에서 인터페이스를 상속받아 강제성을 없애고 싶은 메서드만 재정의 해준다.
이후 어댑터 클래스를 상속받는 자식 클래스는 내가 원하는 메서드만 재정의할 수 있게 된다.
어댑터 클래스의 이름은 이름 뒤에 Adapter를 붙여주어 목적을 알려주는게 좋다.
인터페이스 ----> 어댑터 클래스 ----> 클래스

# 인터페이스의 추가된 문법 (JDK 1.8 부터 추가됨)
1. default 메서드를 선언할 수 있다.

default 리턴타입 메서드명(매개변수) {
	실행할 코드;
}

2. static 메서드를 선언할 수 있다.
static 리턴타입 메서드명(매개변수) {
	실행할 코드;
}

3. private 메서드 (jdk 9 부터 사용 가능)

# 다중 상속
여러 부모 타입을 상속하는 것을 다중 상속이라고 한다.
JAVA는 모호성 때문에 다중 상속을 지원하지 않는다.
하지만 JDK8 이상 부터는 인터페이스에 default 메서드 등을 만드는 것을 허용한다. (특정 메서드의 구현을 허용한다.)

여러 개를 구현할 수 있는 인터페이스의 특징 때문에 다중 상속을 지원하는 것이나 다름없게 되었다.

# 모호성(ambiguity)
하나의 자식이 여러 부모를 상속받을 때 서로 다른 부모 클래스에 동일한 이름의 맴버가 있다면, 어떤 부모의 맴버를 사용해야할 지 알 수 없다.

# 모호성 해결방법 예시
1. 두 개 이상의 인터페이스에 같은 메서드가 선언되어 있는 경우
	-> 자식 클래스에서 재정의하여 사용
2. 부모 클래스의 메서드와 인터페이스의 디폴트 메서드가 같은 경우
	-> 부모 클래스의 메서드가 사용된다.
# 스트림(Stream)
- 배열, 컬렉션 같은 데이터 묶음을 편하고 효율적으로 처리하기 위해 제공되는 API
- 선언형(함수형) 프로그래밍을 자바로 구현해 놓은 클래스
- 람다를 활용할 수 있는 기술이다.
- 스트림은 값의 흐름을 의미한다.

# 선언형 프로그래밍이란?
- 명령형 프로그래밍 : 어떻게 할 것인가? ( 알고리즘 중
for(int i=0; i<ar.length; i++){
	System.out.println(ar[i] + 1);
}

- 선언형 프로그래밍 : 무엇을 할 것인가? (목표에 중점)
Arrays.stream(ar).forEach(num -> System.out.println(num1+1));

# 자바의 선언형 프로그래밍 지원
- JDK8부터 Stream과 Lambda를 지원한다.
- stream에서만 사용 가능한 메서드를 이용하여 프로그래밍 한다.
- 마치 블록을 조립하듯 메서드를 나열하여 프로그래밍한다.(메서드 체이닝)

# 스트림의 종류
- 기본타임 Stream
	IntStream    : int 타입의 테이터를 처리하기 위한 스트림
     DoubleStream : double 타입의             "    
       LongStream   : long 타입의             "
- 객체타입 Stream
	Stream<T> : T타입의 데이터를 처리하는 스트림

# 스트림의 3단계
1. 생성
- 범위를 이용한 생성(기본타입 스트림)
- Arrays를 이용한 생성
- Collection을 이용한 생성
2. 중간연산
- 반환타입이 stream 이다.
- 몇 번이든 사용 가능하다

3. 최종연산
- 반환 타입이 Stream이 아니다.
- 한 번만 사용 가능하다.

# 스트림 특징
1. Stream은 일회용이다. -> 재사용 불가
2. Stream은 원본 데이터를 수정하지 않는다.
